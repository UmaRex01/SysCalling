# Vectored Syscall

## Stuff you should know

A **hardware breakpoint** (also known as a processor breakpoint or data breakpoint) is a mechanism that allows the processor to interrupt the execution of a programme when a specific event occurs. Unlike software breakpoints, which are handled directly by a debugger and modify the code by inserting interrupt instructions, hardware breakpoints use the processor's debug registers without modifying the code.

There are four types of hardware breakpoints, corresponding to the type of memory access being performed:
- Execute: is triggered when an instruction is executed at the specified address;
- Read: is triggered when the memory at the monitored address is read;
- Write: turns ON when memory at the specified address is being written;
- I/O Access: turns ON when an I/O operation is performed on a specified port.

Hardware breakpoints are implemented using registers specifically provided by the processor for debugging operations. Specifically, registers `DR0` to `DR3` are used to specify the memory address at which the breakpoint is to be set, while register `DR7` is used to specify its type.

## Implementation
There are several variations of this technique, outlined in the following 'Related Project' section, but the underlying philosophy remains the same. Essentially, the process involves registering an exception handler, initiating a system call through a specific `ntdll.dll` API, pausing it with a hardware breakpoint, manipulating registers to adjust data as needed, and then resuming execution

The implementation here is specifically inspired by [MutationGate](https://github.com/senzee1984/MutationGate).
The process begins by registering an exception handler. Then, whenever an `ntdll.dll` API needs to be invoked, the following steps are performed:
- a *benign* `ntdll.dll` API is called — one that is unlikely to be monitored by the EDR through inline hooking — while passing in the parameter list intended for the actual target API;
- a hardware breakpoint is set just before the instructions that trigger the transition to kernel mode;
- when this breakpoint is hit, the previously set exception handler intervenes;
- this handler changes the SSN to match the intended syscall and adjusts the `RIP` register so that the next instruction executed is a `syscall` instruction.

## Focus on Call Stack
As a result, the last API called on the call stack before the transition to kernel mode will be an arbitrary `ntdll.dll` API. This behavior can be modified by changing the *benign* API used to trigger the execution of the exception handler.

<p align="center">
  <img width="460" src="https://github.com/user-attachments/assets/8eb3b0ae-5f08-4cf8-b6b3-f5b86ca7ba92">
</p>

## Test Result
The shellcode was successfully executed, and no notifications were generated by the antivirus software.

![vectored](https://github.com/user-attachments/assets/56e3f56b-d8c7-4049-a845-b30e01ccb4dc)

## RELATED PROJECTS

[MutationGate](https://github.com/senzee1984/MutationGate) by @senzee1984\
[HWSyscalls](https://github.com/Dec0ne/HWSyscalls) by Dec0ne\
[TamperingSyscalls](https://github.com/rad9800/TamperingSyscalls) by rad9800\
[VEH-PoC](https://github.com/RedTeamOperations/VEH-PoC) by RedTeamOperations

## REFERENCES

[https://cyberwarfare.live/bypassing-av-edr-hooks-via-vectored-syscall-poc/](https://cyberwarfare.live/bypassing-av-edr-hooks-via-vectored-syscall-poc/)\
[https://redops.at/en/blog/syscalls-via-vectored-exception-handling](https://redops.at/en/blog/syscalls-via-vectored-exception-handling)\
[https://winslow1984.com/books/malware/page/mutationgate](https://winslow1984.com/books/malware/page/mutationgate)\
[https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/processor-breakpoints---ba-breakpoints-](https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/processor-breakpoints---ba-breakpoints-)
